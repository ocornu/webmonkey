/**
 * @fileoverview Implementation of the <code>WebmonkeyService</code> XPCOM
 * service component.
 */

// XPCOM info
const DESCRIPTION = "WebmonkeyService";
const CLASS_ID    = Components.ID("{8d26f120-10b8-11de-8c30-0800200c9a66}");
const CONTRACT_ID = "@webmonkey.info/webmonkey-service;1";

// shortcuts
const Cc = Components.classes;
const Ci = Components.interfaces;

Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");


/**
 * Construct a new Webmonkey service.
 * @class Webmonkey service XPCOM component.
 * Usable from JavaScript only.
 * @constructor
 */
function WebmonkeyService() {
  this.wrappedJSObject = this;
}
WebmonkeyService.prototype = {
  /**
   * Standard XPCOM class description.
   * @type  string
   */
  classDescription:  DESCRIPTION,
  /**
   * Standard XPCOM class ID.
   */
  classID:           CLASS_ID,
  /**
   * Standard XPCOM contract ID.
   * @type  string
   */
  contractID:        CONTRACT_ID,
  /**
   * Standard XPCOM categories.
   * @type  Array
   * @private
   */
  _xpcom_categories: [{category: "app-startup",
                       entry: DESCRIPTION,
                       value: CONTRACT_ID,
                       service: true},
                      {category: "content-policy",
                       entry: CONTRACT_ID,
                       value: CONTRACT_ID,
                       service: true}],

  /**
   * Standard <code>nsISupports</code> dynamic interface loader.
   * Implementation is automatically generated by <code>XPCOMUtils</code>.
   * @function
   */
  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver,
                                         Ci.nsISupports,
                                         Ci.nsISupportsWeakReference,
                                         Ci.nsIContentPolicy]),

  /**
   * <code>nsIObserver</code> event handler.
   * Is called once on application startup to load subscripts.
   */
  observe: function(aSubject, aTopic, aData) {
    if (aTopic != "app-startup") return;
    Components.utils.import("resource://webmonkey/config.js");
    var loader = Cc["@mozilla.org/moz/jssubscript-loader;1"]
                 .getService(Ci.mozIJSSubScriptLoader);
    loader.loadSubScript("chrome://global/content/XPCNativeWrapper.js");
    loader.loadSubScript("chrome://webmonkey/content/lib/utils.js");
  },

  /**
   * <code>nsIContentPolicy</code> resource loader hook.
   * Allow all resources to be loaded except userscripts, which are redirected
   * to the script installer.
   * @type  int
   */
  shouldLoad: function(contentType, contentLocation, requestOrigin, context,
                       mimeTypeGuess, extra) {
    var ret = Ci.nsIContentPolicy.ACCEPT;

    // block content detection of webmonkey by denying GM
    // chrome content, unless loaded from chrome
    if (requestOrigin && requestOrigin.scheme != "chrome"
        && contentLocation.scheme == "chrome"
        && contentLocation.host == "webmonkey")
      return Ci.nsIContentPolicy.REJECT_SERVER;

    // don't intercept anything when GM is not enabled
    if (!GM_getEnabled()) return ret;

    // don't interrupt the view-source: scheme
    // (triggered if the link in the error console is clicked)
    if (contentLocation.scheme == "view-source") return ret;

    if (contentType == Ci.nsIContentPolicy.TYPE_DOCUMENT
        && contentLocation.spec.match(/\.user\.js$/)) {
      var winWat = Cc["@mozilla.org/embedcomp/window-watcher;1"]
                   .getService(Ci.nsIWindowWatcher);
      if (winWat.activeWindow && winWat.activeWindow.GM_BrowserUI) {
        winWat.activeWindow.GM_BrowserUI.downloadScript(contentLocation, true);
        ret = Ci.nsIContentPolicy.REJECT_REQUEST;
      }
    }

    return ret;
  },

  /**
  * <code>nsIContentPolicy</code> resource processor hook.
  * All resources are allowed to be processed.
  * @type   int
  */
  shouldProcess: function(contentType, contentLocation, requestOrigin, context,
                          mimeTypeGuess, extra) {
    return Ci.nsIContentPolicy.ACCEPT;
  },

  /**
   * Webmonkey configuration.
   * @private
   */
  _config: null,
  get config() {
    if (!this._config)
      this._config = new Config();
    return this._config;
  },

  /**
   * <code>DOMContentLoaded</code> event handler.
   * Inject relevant scripts once DOM is fully loaded.
   * @param {Window} unsafeWin
   *        Target DOM window.
   * @param {ChromeWindow} chromeWin
   *        Target chrome window.
   * @param {GM_BrowserUI} gmBrowser
   *        <code>GM_BrowserUI</code> responsible for this chrome window.
   */
  domContentLoaded: function(unsafeWin, chromeWin, gmBrowser) {
    var safeWin   = new XPCNativeWrapper(unsafeWin);
    var href      = safeWin.location.href;
    var scripts   = this.config.getMatchingScripts(
      function(script) { return script.meta.enabled && script.isRunnable(href); }
    );
    // assert there are scripts to inject
    if (!scripts.length) return;

    var firebug = getFirebugConsole(safeWin, unsafeWin, chromeWin);
    for each (var script in scripts)
      script.inject(unsafeWin, gmBrowser, firebug);
  }

};


var components = [WebmonkeyService];
/**
 * Standard XPCOM module registration.
 */
function NSGetModule(compMgr, fileSpec) {
  return XPCOMUtils.generateModule(components);
}


/* FireBug 1.2+ console support */
function getFirebugConsole(safeWin, unsafeWin, chromeWin) {
  try {
    chromeWin = chromeWin.top;
    // assert FB is installed
    if (!chromeWin.Firebug)
      return null;
    var fbVersion = parseFloat(chromeWin.Firebug.version);
    var fbConsole = chromeWin.Firebug.Console;
    var fbContext = chromeWin.TabWatcher &&
                    chromeWin.TabWatcher.getContextByWindow(unsafeWin);
    // assert FB is enabled
    if (!fbConsole.isEnabled(fbContext))
      return null;

    if (fbVersion == 1.2) {
      // search console handler
      if (fbContext.consoleHandler)
        for (var i = 0; i < fbContext.consoleHandler.length; i++)
          if (fbContext.consoleHandler[i].window == safeWin)
            return fbContext.consoleHandler[i].handler;
      var dummyElm = safeWin.document.createElement("div");
      dummyElm.setAttribute("id", "_firebugConsole");
      safeWin.document.documentElement.appendChild(dummyElm);
      chromeWin.Firebug.Console.injector.addConsoleListener(fbContext, safeWin);
      dummyElm.parentNode.removeChild(dummyElm);
      return fbContext.consoleHandler.pop().handler;
    }

    if (fbVersion == 1.3 || fbVersion == 1.4) {
      fbConsole.injector.attachIfNeeded(fbContext, unsafeWin);
      // find active context
      for (var i=0; i<fbContext.activeConsoleHandlers.length; i++)
        if (fbContext.activeConsoleHandlers[i].window == unsafeWin)
          return fbContext.activeConsoleHandlers[i];
      return null;
    }
  } catch (e) {
    dump('Webmonkey getFirebugConsole() error:\n'+uneval(e)+'\n');
  }
  return null;
}
